#!/usr/bin/env node --use_strict

var _ = require('lodash')
    , AWS = require('aws-sdk')
    , commands = require('../lib/commands')
    , fs = require('fs')
    , NovaError = require('../lib/nova-error')
    , getopt = require('node-getopt')
    , path = require('path')
    , program = require('../lib/program')
    , util = require('util')
    , utils = require('../lib/utils')
    , yaml = require('js-yaml');

function parseCommandLine() {
    var args = process.argv.slice(2);

    // find index of the first command (if present)
    var commandIndex = _(commands)
        .keys()
        .map((command) => {
            return _.indexOf(args, command);
        })
        .find((idx) => {
            return idx != -1;
        });

    var programArgs = [];
    var commandName;
    var commandArgs = [];

    if (typeof commandIndex == 'undefined') {
        programArgs = args;
    } else {
        programArgs = args.slice(0, commandIndex);
        commandName = args[commandIndex];
        commandArgs = args.slice(commandIndex + 1);
    }

    var programOptions = getopt.create([
        ['', 'profile=ARG', 'Set which aws profile to use for credentials'],
        ['', 'params=ARG+', 'Yml configuration file passed in to your nova deployment definition'],
        ['v', 'verbose', 'Print more stuff'],
        ['d', 'debug', 'Print insane amounts of logs'],
        ['f', 'output-format=ARG', 'Output format (json or text) - defaults to json'],
        ['', 'version', 'Display current version'],
        ['h', 'help', 'Display help'],
    ]);

    var commandDescriptions = _.map(commands, function(command, name) {
        // Pad right to get consistent tabs
        const maxCommandLengthBeforeTab = 8;
        name = _.padEnd((name + ':'), maxCommandLengthBeforeTab);
        return util.format('  %s\t%s', name, command.descriptionText);
    }).join('\n');

    programOptions.setHelp(util.format(
'Usage: nova [common_options] command [command_options]\n\n\
Common options:\n\
[[OPTIONS]]\n\n\
Commands:\n\
%s\n\
', commandDescriptions));

    var parsedProgramOptions = programOptions.parse(programArgs);

    if (parsedProgramOptions.argv.length !== 0) {
        // something is wrong, we shouldn't have left over argument here,
        // treat it as fake command name to report an error later.
        commandName = parsedProgramOptions.argv[0];
    }

    var showHelp = (errorMessage) => {
        if (errorMessage) {
            console.error('Error:', errorMessage, '\n');
        }
        console.error(programOptions.getHelp());
    };

    var outputFormat = parsedProgramOptions.options['output-format'] = parsedProgramOptions.options['output-format'] || 'text';
    if (outputFormat !== 'text' && outputFormat !== 'json') {
        showHelp('Invalid output format');
        process.exit(0);
    }

    if (commandName && !commands[commandName]) {
        showHelp('Unknown command specified - ' + commandName);
        process.exit(0);
    }

    if (parsedProgramOptions.options['debug']) {
        parsedProgramOptions.options['verbose'] = true;
    }

    return {
        programOptions: parsedProgramOptions.options,
        commandName: commandName,
        commandArguments: commandArgs,
        showHelp: showHelp,
    };
}

function parseCommandArguments(commandName, commandArguments) {
    var command = commands[commandName];
    var extendedCommandOptions = (command.options || []).concat([['h', 'help', 'Display help']]);
    var commandOptions = getopt.create(extendedCommandOptions);
    commandOptions.setHelp('[[OPTIONS]]\n');

    var parsedCommandOptions = commandOptions.parse(commandArguments);

    var showHelp = (errorMessage) => {
        var commandUsage = commands[commandName].usageText;
        if (errorMessage) {
            console.error('Error: ' + errorMessage);
        }

    console.error(util.format(
'\nUsage: nova %s %s\n\n\
Options:\n\
%s\n'
, commandName, commandUsage, commandOptions.getHelp()));
    }

    return {
        commandOptions: parsedCommandOptions,
        showHelp: showHelp,
    };
}

function initAws(profile, debug) {
    if (debug) {
        AWS.config.logger = process.stdout;
    }

    var credentials =
        profile
            ? new AWS.SharedIniFileCredentials({ profile: profile })
            : new AWS.EnvironmentCredentials('AWS');

    return new Promise((resolve, reject) => {
        credentials.refresh((err) => {
            if (err) {
                reject(new Error('Failed to initialize AWS - make sure you provide --profile or set AWS_ACCESS_KEY_ID env var'));
                return;
            }

            AWS.config.credentials = credentials;
            resolve();
        });
    });
}

function mergeDeep(value1, value2, resolver) {
    function _mergeDeep(value1, value2, path1, path2) {
        if (typeof value1 !== typeof value2) {
            return resolver(value1, value2, path1, path2) || value2;
        }

        if (_.isArray(value1) && _.isArray(value2)) {
            return resolver(value1, value2, path1, path2) || value1.concat(value2);
        } else if (_.isArray(value1) || _.isArray(value2)) {
            return resolver(value1, value2, path1, path2) || value2;
        }

        if (_.isObject(value1) && _.isObject(value2)) {
            var keys1 = _.keys(value1);
            var keys2 = _.keys(value2);

            var result = {};

            // add distinct keys
            var distinctKeys = _.difference(keys1, keys2).concat(_.difference(keys2, keys1));
            result = _.extend(result,
              _.pick(value1, distinctKeys),
              _.pick(value2, distinctKeys));

            // recursively merge common keys
            var commonKeys = _.intersection(keys1, keys2);
            var common = _.reduce(commonKeys, function(memo, key) {
                var value = _mergeDeep(value1[key], value2[key], path1+'.'+key, path2+'.'+key);
                memo[key] = value;
                return memo;
            }, {});

            result = _.extend(result, common);
            return result;
        }

        return resolver(value1, value2, path1, path2) || value2;
    }

    if (!_.isObject(value1) || !_.isObject(value2)) {
        resolver(null, null, '<root>', '<root>');
        return value2;
    }

    return _mergeDeep(value1, value2, '', '');
}

function readParams(paramsFiles) {
    if (!paramsFiles || paramsFiles.length === 0) {
        return Promise.resolve({});
    }

    var promises = _.map(paramsFiles, (paramsFile) => {
        var readFile = utils.pbind(fs.readFile, fs, paramsFile, { encoding: 'utf-8', flag: 'r' });
        return readFile();
    });

    return Promise.all(promises).then((datas) => {
        return _.reduce(datas, (memo, data) => {
            var object = yaml.safeLoad(data) || {};

            return mergeDeep(memo, object, (value1, value2, path1, path2) => {
                console.log('Warning: cannot cleanly merge params files ("%s" and "%s")...', path1, path2);
            });
        }, {});
    });
}

function executeCommand(commandName, commandArguments) {
    var command = commands[commandName];
    return new Promise((resolve, reject) => {
        try {
            resolve(new command(commandArguments.commandOptions));
        } catch (e) {
            reject(e);
        }
    }).then((command) => {
        return command.execute();
    });
}

var commandLine = parseCommandLine();

if (commandLine.programOptions.help) {
    commandLine.showHelp();
    process.exit(0);
}

if (commandLine.programOptions.version) {
    console.log(program.getVersion());
    process.exit(0);
}

if (!commands[commandLine.commandName]) {
    commandLine.showHelp('Expected command');
    process.exit(0);
}

var commandArguments = parseCommandArguments(commandLine.commandName, commandLine.commandArguments);

if (commandArguments.commandOptions.options.help) {
    commandArguments.showHelp();
    process.exit(0);
}

var initAwsPromise = commands[commandLine.commandName].skipAws
    ? ''
    : initAws(commandLine.programOptions.profile, commandLine.programOptions.debug);

Promise.all([
    readParams(commandLine.programOptions.params),
    initAwsPromise,
]).then(values => {
    var paramsObject = values[0];

    program.options = commandLine.programOptions;
    program.params = paramsObject;

    return executeCommand(commandLine.commandName, commandArguments);
}, err => {
    if (!(err instanceof Error)) {
        commandLine.showHelp('Unexpected error object: ' + err);
        return;
    }

    if (commandLine.programOptions.debug) {
        commandLine.showHelp(err.stack);
    } else {
        commandLine.showHelp(err.message);
    }
}).catch(err => {
    if (err instanceof NovaError) {
        console.log(err.toString());
        return;
    }

    if (!(err instanceof Error)) {
        commandArguments.showHelp('Unexpected error object: ' + err);
        return;
    }

    if (commandLine.programOptions.debug) {
        commandArguments.showHelp(err.stack);
    } else {
        commandArguments.showHelp(err.message);
    }
});
